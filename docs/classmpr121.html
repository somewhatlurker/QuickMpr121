<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "https://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.8.17"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>QuickMpr121: mpr121 Class Reference</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="navtree.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="resize.js"></script>
<script type="text/javascript" src="navtreedata.js"></script>
<script type="text/javascript" src="navtree.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
  $(document).ready(function() { init_search(); });
/* @license-end */
</script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td id="projectalign" style="padding-left: 0.5em;">
   <div id="projectname">QuickMpr121
   </div>
  </td>
   <td>        <div id="MSearchBox" class="MSearchBoxInactive">
        <span class="left">
          <img id="MSearchSelect" src="search/mag_sel.png"
               onmouseover="return searchBox.OnSearchSelectShow()"
               onmouseout="return searchBox.OnSearchSelectHide()"
               alt=""/>
          <input type="text" id="MSearchField" value="Search" accesskey="S"
               onfocus="searchBox.OnSearchFieldFocus(true)" 
               onblur="searchBox.OnSearchFieldFocus(false)" 
               onkeyup="searchBox.OnSearchFieldChange(event)"/>
          </span><span class="right">
            <a id="MSearchClose" href="javascript:searchBox.CloseResultsWindow()"><img id="MSearchCloseImg" border="0" src="search/close.png" alt=""/></a>
          </span>
        </div>
</td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.8.17 -->
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
var searchBox = new SearchBox("searchBox", "search",false,'Search');
/* @license-end */
</script>
</div><!-- top -->
<div id="side-nav" class="ui-resizable side-nav-resizable">
  <div id="nav-tree">
    <div id="nav-tree-contents">
      <div id="nav-sync" class="sync"></div>
    </div>
  </div>
  <div id="splitbar" style="-moz-user-select:none;" 
       class="ui-resizable-handle">
  </div>
</div>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
$(document).ready(function(){initNavTree('classmpr121.html',''); initResizable(); });
/* @license-end */
</script>
<div id="doc-content">
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

<div class="header">
  <div class="summary">
<a href="#pub-methods">Public Member Functions</a> &#124;
<a href="#pub-attribs">Public Attributes</a> &#124;
<a href="classmpr121-members.html">List of all members</a>  </div>
  <div class="headertitle">
<div class="title">mpr121 Class Reference</div>  </div>
</div><!--header-->
<div class="contents">

<p>Main <a class="el" href="classmpr121.html" title="Main mpr121 class.">mpr121</a> class.  
 <a href="classmpr121.html#details">More...</a></p>

<p><code>#include &lt;<a class="el" href="_quick_mpr121_8h_source.html">QuickMpr121.h</a>&gt;</code></p>
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pub-methods"></a>
Public Member Functions</h2></td></tr>
<tr class="memitem:ac6a476c441a682a5573e7b8957f375ab"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmpr121.html#ac6a476c441a682a5573e7b8957f375ab">mpr121</a> (byte addr=0, TwoWire *wire=&amp;Wire)</td></tr>
<tr class="memdesc:ac6a476c441a682a5573e7b8957f375ab"><td class="mdescLeft">&#160;</td><td class="mdescRight">Creates an MPR121 device with sane default settings.  <a href="classmpr121.html#ac6a476c441a682a5573e7b8957f375ab">More...</a><br /></td></tr>
<tr class="separator:ac6a476c441a682a5573e7b8957f375ab"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac3e687df193f083c5b215c28122cffd7"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmpr121.html#ac3e687df193f083c5b215c28122cffd7">readTouchState</a> (byte electrode)</td></tr>
<tr class="memdesc:ac3e687df193f083c5b215c28122cffd7"><td class="mdescLeft">&#160;</td><td class="mdescRight">Reads one touch state bool.  <a href="classmpr121.html#ac3e687df193f083c5b215c28122cffd7">More...</a><br /></td></tr>
<tr class="separator:ac3e687df193f083c5b215c28122cffd7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a63ae10501fb6b3e51c3d8ee19907fbd5"><td class="memItemLeft" align="right" valign="top">short&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmpr121.html#a63ae10501fb6b3e51c3d8ee19907fbd5">readTouchState</a> ()</td></tr>
<tr class="memdesc:a63ae10501fb6b3e51c3d8ee19907fbd5"><td class="mdescLeft">&#160;</td><td class="mdescRight">Reads the 13 touch state bits.  <a href="classmpr121.html#a63ae10501fb6b3e51c3d8ee19907fbd5">More...</a><br /></td></tr>
<tr class="separator:a63ae10501fb6b3e51c3d8ee19907fbd5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aafa21063d20fbb7fb4fa89b081231c94"><td class="memItemLeft" align="right" valign="top">short&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmpr121.html#aafa21063d20fbb7fb4fa89b081231c94">readOORState</a> ()</td></tr>
<tr class="memdesc:aafa21063d20fbb7fb4fa89b081231c94"><td class="mdescLeft">&#160;</td><td class="mdescRight">Reads the 15 out of range bits.  <a href="classmpr121.html#aafa21063d20fbb7fb4fa89b081231c94">More...</a><br /></td></tr>
<tr class="separator:aafa21063d20fbb7fb4fa89b081231c94"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a16e21396fbe46fa375737f3cfe9ad860"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmpr121.html#a16e21396fbe46fa375737f3cfe9ad860">readOverCurrent</a> ()</td></tr>
<tr class="memdesc:a16e21396fbe46fa375737f3cfe9ad860"><td class="mdescLeft">&#160;</td><td class="mdescRight">Reads the over current flag.  <a href="classmpr121.html#a16e21396fbe46fa375737f3cfe9ad860">More...</a><br /></td></tr>
<tr class="separator:a16e21396fbe46fa375737f3cfe9ad860"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a38b74ad084a9971e4682572e5c1560ee"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmpr121.html#a38b74ad084a9971e4682572e5c1560ee">clearOverCurrent</a> ()</td></tr>
<tr class="memdesc:a38b74ad084a9971e4682572e5c1560ee"><td class="mdescLeft">&#160;</td><td class="mdescRight">Clears the over current flag.  <a href="classmpr121.html#a38b74ad084a9971e4682572e5c1560ee">More...</a><br /></td></tr>
<tr class="separator:a38b74ad084a9971e4682572e5c1560ee"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abe20e7de3f5e2035d1a3419a35c9bf90"><td class="memItemLeft" align="right" valign="top"><a id="abe20e7de3f5e2035d1a3419a35c9bf90"></a>
short *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmpr121.html#abe20e7de3f5e2035d1a3419a35c9bf90">readElectrodeData</a> (byte electrode, byte count)</td></tr>
<tr class="memdesc:abe20e7de3f5e2035d1a3419a35c9bf90"><td class="mdescLeft">&#160;</td><td class="mdescRight">Reads filtered analog data for consecutive electrodes. <br /></td></tr>
<tr class="separator:abe20e7de3f5e2035d1a3419a35c9bf90"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aff93f8113038502852b265df72ac58b5"><td class="memItemLeft" align="right" valign="top"><a id="aff93f8113038502852b265df72ac58b5"></a>
short&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmpr121.html#aff93f8113038502852b265df72ac58b5">readElectrodeData</a> (byte electrode)</td></tr>
<tr class="memdesc:aff93f8113038502852b265df72ac58b5"><td class="mdescLeft">&#160;</td><td class="mdescRight">Reads filtered analog data for a single electrode. <br /></td></tr>
<tr class="separator:aff93f8113038502852b265df72ac58b5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af407727a11f7efc874af3fbab0b38ddd"><td class="memItemLeft" align="right" valign="top"><a id="af407727a11f7efc874af3fbab0b38ddd"></a>
byte *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmpr121.html#af407727a11f7efc874af3fbab0b38ddd">readElectrodeBaseline</a> (byte electrode, byte count)</td></tr>
<tr class="memdesc:af407727a11f7efc874af3fbab0b38ddd"><td class="mdescLeft">&#160;</td><td class="mdescRight">Reads baseline values for consecutive electrodes. <br /></td></tr>
<tr class="separator:af407727a11f7efc874af3fbab0b38ddd"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3304da226706e6e60adf2181299b95fc"><td class="memItemLeft" align="right" valign="top"><a id="a3304da226706e6e60adf2181299b95fc"></a>
byte&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmpr121.html#a3304da226706e6e60adf2181299b95fc">readElectrodeBaseline</a> (byte electrode)</td></tr>
<tr class="memdesc:a3304da226706e6e60adf2181299b95fc"><td class="mdescLeft">&#160;</td><td class="mdescRight">Reads the baseline value for a single electrode. <br /></td></tr>
<tr class="separator:a3304da226706e6e60adf2181299b95fc"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5df3abe4bcee63fd5cf25f2af887f23f"><td class="memItemLeft" align="right" valign="top"><a id="a5df3abe4bcee63fd5cf25f2af887f23f"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmpr121.html#a5df3abe4bcee63fd5cf25f2af887f23f">writeElectrodeBaseline</a> (byte electrode, byte count, byte value)</td></tr>
<tr class="memdesc:a5df3abe4bcee63fd5cf25f2af887f23f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Writes a baseline value to consecutive electrodes. <br /></td></tr>
<tr class="separator:a5df3abe4bcee63fd5cf25f2af887f23f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae5dfa5ebaa5759552c8fdb9394b3f448"><td class="memItemLeft" align="right" valign="top"><a id="ae5dfa5ebaa5759552c8fdb9394b3f448"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmpr121.html#ae5dfa5ebaa5759552c8fdb9394b3f448">writeElectrodeBaseline</a> (byte electrode, byte value)</td></tr>
<tr class="memdesc:ae5dfa5ebaa5759552c8fdb9394b3f448"><td class="mdescLeft">&#160;</td><td class="mdescRight">Writes the baseline value for a single electrode. <br /></td></tr>
<tr class="separator:ae5dfa5ebaa5759552c8fdb9394b3f448"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8d889cab82974749203f22c5b17b97a4"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmpr121.html#a8d889cab82974749203f22c5b17b97a4">setAllThresholds</a> (byte touched, byte released, bool prox)</td></tr>
<tr class="memdesc:a8d889cab82974749203f22c5b17b97a4"><td class="mdescLeft">&#160;</td><td class="mdescRight">A quick way to set all ::touchThresholds and ::releaseThresholds.  <a href="classmpr121.html#a8d889cab82974749203f22c5b17b97a4">More...</a><br /></td></tr>
<tr class="separator:a8d889cab82974749203f22c5b17b97a4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a390d14e572542715030b38228ba1b148"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmpr121.html#a390d14e572542715030b38228ba1b148">setGPIOMode</a> (byte pin, byte count, <a class="el" href="_quick_mpr121_enums_8h.html#a3bbfc0ca52598381c8dcc6d45b08b4ea">mpr121GPIOMode</a> mode)</td></tr>
<tr class="memdesc:a390d14e572542715030b38228ba1b148"><td class="mdescLeft">&#160;</td><td class="mdescRight">Sets pin mode for consecutive GPIO pins.  <a href="classmpr121.html#a390d14e572542715030b38228ba1b148">More...</a><br /></td></tr>
<tr class="separator:a390d14e572542715030b38228ba1b148"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a79321eedcc84a0d62445c8d120d2d98d"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmpr121.html#a79321eedcc84a0d62445c8d120d2d98d">setGPIOMode</a> (byte pin, <a class="el" href="_quick_mpr121_enums_8h.html#a3bbfc0ca52598381c8dcc6d45b08b4ea">mpr121GPIOMode</a> mode)</td></tr>
<tr class="memdesc:a79321eedcc84a0d62445c8d120d2d98d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Sets pin mode for a single GPIO pin.  <a href="classmpr121.html#a79321eedcc84a0d62445c8d120d2d98d">More...</a><br /></td></tr>
<tr class="separator:a79321eedcc84a0d62445c8d120d2d98d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8c95d57f0024f77ca65dba9dd44326cc"><td class="memItemLeft" align="right" valign="top"><a id="a8c95d57f0024f77ca65dba9dd44326cc"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmpr121.html#a8c95d57f0024f77ca65dba9dd44326cc">writeGPIODigital</a> (byte pin, byte count, bool value)</td></tr>
<tr class="memdesc:a8c95d57f0024f77ca65dba9dd44326cc"><td class="mdescLeft">&#160;</td><td class="mdescRight">Writes a digital value to consecutive GPIO pins. <br /></td></tr>
<tr class="separator:a8c95d57f0024f77ca65dba9dd44326cc"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8458ac5bca782046018bc793c7deb73d"><td class="memItemLeft" align="right" valign="top"><a id="a8458ac5bca782046018bc793c7deb73d"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmpr121.html#a8458ac5bca782046018bc793c7deb73d">writeGPIODigital</a> (byte pin, bool value)</td></tr>
<tr class="memdesc:a8458ac5bca782046018bc793c7deb73d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Writes a digital value to a single GPIO pin. <br /></td></tr>
<tr class="separator:a8458ac5bca782046018bc793c7deb73d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a82e0215c013429d7b2d88359fdacd162"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmpr121.html#a82e0215c013429d7b2d88359fdacd162">writeGPIOAnalog</a> (byte pin, byte count, byte value)</td></tr>
<tr class="memdesc:a82e0215c013429d7b2d88359fdacd162"><td class="mdescLeft">&#160;</td><td class="mdescRight">Writes an "analog" (PWM) value to consecutive GPIO pins.  <a href="classmpr121.html#a82e0215c013429d7b2d88359fdacd162">More...</a><br /></td></tr>
<tr class="separator:a82e0215c013429d7b2d88359fdacd162"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a671d4894de14e9b197a54b5ee264d85f"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmpr121.html#a671d4894de14e9b197a54b5ee264d85f">writeGPIOAnalog</a> (byte pin, byte value)</td></tr>
<tr class="memdesc:a671d4894de14e9b197a54b5ee264d85f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Writes an "analog" (PWM) value to a single GPIO pin.  <a href="classmpr121.html#a671d4894de14e9b197a54b5ee264d85f">More...</a><br /></td></tr>
<tr class="separator:a671d4894de14e9b197a54b5ee264d85f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:acf4591d8841ef5ab9c0f9394877d6b72"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmpr121.html#acf4591d8841ef5ab9c0f9394877d6b72">begin</a> (unsigned long clock=400000)</td></tr>
<tr class="memdesc:acf4591d8841ef5ab9c0f9394877d6b72"><td class="mdescLeft">&#160;</td><td class="mdescRight">Optional alternative to using Wire.begin() and Wire.setClock().  <a href="classmpr121.html#acf4591d8841ef5ab9c0f9394877d6b72">More...</a><br /></td></tr>
<tr class="separator:acf4591d8841ef5ab9c0f9394877d6b72"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a333400f6bc6ad369be09850c982c4785"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmpr121.html#a333400f6bc6ad369be09850c982c4785">start</a> (byte electrodes)</td></tr>
<tr class="memdesc:a333400f6bc6ad369be09850c982c4785"><td class="mdescLeft">&#160;</td><td class="mdescRight">Applies settings and enters run mode with a given number of electrodes.  <a href="classmpr121.html#a333400f6bc6ad369be09850c982c4785">More...</a><br /></td></tr>
<tr class="separator:a333400f6bc6ad369be09850c982c4785"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a23f01f768baaaff557798a6131f44c06"><td class="memItemLeft" align="right" valign="top"><a id="a23f01f768baaaff557798a6131f44c06"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmpr121.html#a23f01f768baaaff557798a6131f44c06">stop</a> ()</td></tr>
<tr class="memdesc:a23f01f768baaaff557798a6131f44c06"><td class="mdescLeft">&#160;</td><td class="mdescRight">Exits run mode. <br /></td></tr>
<tr class="separator:a23f01f768baaaff557798a6131f44c06"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a879d8f0af08961dbcc80e01def07040c"><td class="memItemLeft" align="right" valign="top"><a id="a879d8f0af08961dbcc80e01def07040c"></a>
bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmpr121.html#a879d8f0af08961dbcc80e01def07040c">checkRunning</a> ()</td></tr>
<tr class="memdesc:a879d8f0af08961dbcc80e01def07040c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Checks if the MPR121 is in run mode. <br /></td></tr>
<tr class="separator:a879d8f0af08961dbcc80e01def07040c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a95f5407f1524c164cb60c62459ccf61e"><td class="memItemLeft" align="right" valign="top"><a id="a95f5407f1524c164cb60c62459ccf61e"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmpr121.html#a95f5407f1524c164cb60c62459ccf61e">softReset</a> ()</td></tr>
<tr class="memdesc:a95f5407f1524c164cb60c62459ccf61e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Resets the MPR121. <br /></td></tr>
<tr class="separator:a95f5407f1524c164cb60c62459ccf61e"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pub-attribs"></a>
Public Attributes</h2></td></tr>
<tr class="memitem:afa45615edefecb83832c255af3a13634"><td class="memItemLeft" align="right" valign="top"><a id="afa45615edefecb83832c255af3a13634"></a>
byte&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmpr121.html#afa45615edefecb83832c255af3a13634">touchThresholds</a> [13]</td></tr>
<tr class="memdesc:afa45615edefecb83832c255af3a13634"><td class="mdescLeft">&#160;</td><td class="mdescRight">Touch detection thresholds for ELE0-ELE11, ELEPROX. <br /></td></tr>
<tr class="separator:afa45615edefecb83832c255af3a13634"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a809903171355b2893fe268df3c3b20bb"><td class="memItemLeft" align="right" valign="top"><a id="a809903171355b2893fe268df3c3b20bb"></a>
byte&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmpr121.html#a809903171355b2893fe268df3c3b20bb">releaseThresholds</a> [13]</td></tr>
<tr class="memdesc:a809903171355b2893fe268df3c3b20bb"><td class="mdescLeft">&#160;</td><td class="mdescRight">Release detection thresholds for ELE0-ELE11, ELEPROX. <br /></td></tr>
<tr class="separator:a809903171355b2893fe268df3c3b20bb"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a88e2ab002af8ff5c9980405e9823156c"><td class="memItemLeft" align="right" valign="top"><a id="a88e2ab002af8ff5c9980405e9823156c"></a>
byte&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmpr121.html#a88e2ab002af8ff5c9980405e9823156c">MHDrising</a></td></tr>
<tr class="memdesc:a88e2ab002af8ff5c9980405e9823156c"><td class="mdescLeft">&#160;</td><td class="mdescRight">"Max Half Delta" rising baseline adjustment value (AN3891) &ndash; max: 63 <br /></td></tr>
<tr class="separator:a88e2ab002af8ff5c9980405e9823156c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aae2209dcf507d6c341681e4e62f8389c"><td class="memItemLeft" align="right" valign="top"><a id="aae2209dcf507d6c341681e4e62f8389c"></a>
byte&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmpr121.html#aae2209dcf507d6c341681e4e62f8389c">MHDfalling</a></td></tr>
<tr class="memdesc:aae2209dcf507d6c341681e4e62f8389c"><td class="mdescLeft">&#160;</td><td class="mdescRight">"Max Half Delta" falling baseline adjustment value (AN3891) &ndash; max: 63 <br /></td></tr>
<tr class="separator:aae2209dcf507d6c341681e4e62f8389c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aabaf603b673666f22d5db0fc4c874f0b"><td class="memItemLeft" align="right" valign="top"><a id="aabaf603b673666f22d5db0fc4c874f0b"></a>
byte&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmpr121.html#aabaf603b673666f22d5db0fc4c874f0b">NHDrising</a></td></tr>
<tr class="memdesc:aabaf603b673666f22d5db0fc4c874f0b"><td class="mdescLeft">&#160;</td><td class="mdescRight">"Noise Half Delta" rising baseline adjustment value (AN3891) &ndash; max: 63 <br /></td></tr>
<tr class="separator:aabaf603b673666f22d5db0fc4c874f0b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a271e0819d9e8b52453cd52527c6a6bc8"><td class="memItemLeft" align="right" valign="top"><a id="a271e0819d9e8b52453cd52527c6a6bc8"></a>
byte&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmpr121.html#a271e0819d9e8b52453cd52527c6a6bc8">NHDfalling</a></td></tr>
<tr class="memdesc:a271e0819d9e8b52453cd52527c6a6bc8"><td class="mdescLeft">&#160;</td><td class="mdescRight">"Noise Half Delta" falling baseline adjustment value (AN3891) &ndash; max: 63 <br /></td></tr>
<tr class="separator:a271e0819d9e8b52453cd52527c6a6bc8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1445b88dbc3b8faf5c7cb59915d87a18"><td class="memItemLeft" align="right" valign="top"><a id="a1445b88dbc3b8faf5c7cb59915d87a18"></a>
byte&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmpr121.html#a1445b88dbc3b8faf5c7cb59915d87a18">NHDtouched</a></td></tr>
<tr class="memdesc:a1445b88dbc3b8faf5c7cb59915d87a18"><td class="mdescLeft">&#160;</td><td class="mdescRight">"Noise Half Delta" touched baseline adjustment value (AN3891) &ndash; max: 63 <br /></td></tr>
<tr class="separator:a1445b88dbc3b8faf5c7cb59915d87a18"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0886f06bb5b4e7efa068f04c12394783"><td class="memItemLeft" align="right" valign="top"><a id="a0886f06bb5b4e7efa068f04c12394783"></a>
byte&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmpr121.html#a0886f06bb5b4e7efa068f04c12394783">NCLrising</a></td></tr>
<tr class="memdesc:a0886f06bb5b4e7efa068f04c12394783"><td class="mdescLeft">&#160;</td><td class="mdescRight">"Noise Count Limit" rising baseline adjustment value (AN3891) <br /></td></tr>
<tr class="separator:a0886f06bb5b4e7efa068f04c12394783"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aca476b250322e99af46cc74b9e8c27de"><td class="memItemLeft" align="right" valign="top"><a id="aca476b250322e99af46cc74b9e8c27de"></a>
byte&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmpr121.html#aca476b250322e99af46cc74b9e8c27de">NCLfalling</a></td></tr>
<tr class="memdesc:aca476b250322e99af46cc74b9e8c27de"><td class="mdescLeft">&#160;</td><td class="mdescRight">"Noise Count Limit" falling baseline adjustment value (AN3891) <br /></td></tr>
<tr class="separator:aca476b250322e99af46cc74b9e8c27de"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a106822d8f438147b3399bebf0f39c609"><td class="memItemLeft" align="right" valign="top"><a id="a106822d8f438147b3399bebf0f39c609"></a>
byte&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmpr121.html#a106822d8f438147b3399bebf0f39c609">NCLtouched</a></td></tr>
<tr class="memdesc:a106822d8f438147b3399bebf0f39c609"><td class="mdescLeft">&#160;</td><td class="mdescRight">"Noise Count Limit" touched baseline adjustment value (AN3891) <br /></td></tr>
<tr class="separator:a106822d8f438147b3399bebf0f39c609"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab9473c12735b050ebbe0f8427c6b6c0f"><td class="memItemLeft" align="right" valign="top"><a id="ab9473c12735b050ebbe0f8427c6b6c0f"></a>
byte&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmpr121.html#ab9473c12735b050ebbe0f8427c6b6c0f">FDLrising</a></td></tr>
<tr class="memdesc:ab9473c12735b050ebbe0f8427c6b6c0f"><td class="mdescLeft">&#160;</td><td class="mdescRight">"Filter Delay Limit" rising baseline adjustment value (AN3891) <br /></td></tr>
<tr class="separator:ab9473c12735b050ebbe0f8427c6b6c0f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aca5c4884519150ece44b92e27e80c6e9"><td class="memItemLeft" align="right" valign="top"><a id="aca5c4884519150ece44b92e27e80c6e9"></a>
byte&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmpr121.html#aca5c4884519150ece44b92e27e80c6e9">FDLfalling</a></td></tr>
<tr class="memdesc:aca5c4884519150ece44b92e27e80c6e9"><td class="mdescLeft">&#160;</td><td class="mdescRight">"Filter Delay Limit" falling baseline adjustment value (AN3891) <br /></td></tr>
<tr class="separator:aca5c4884519150ece44b92e27e80c6e9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab56fe7eeee5ef85db508031ff16ae385"><td class="memItemLeft" align="right" valign="top"><a id="ab56fe7eeee5ef85db508031ff16ae385"></a>
byte&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmpr121.html#ab56fe7eeee5ef85db508031ff16ae385">FDLtouched</a></td></tr>
<tr class="memdesc:ab56fe7eeee5ef85db508031ff16ae385"><td class="mdescLeft">&#160;</td><td class="mdescRight">"Filter Delay Limit" touched baseline adjustment value (AN3891) <br /></td></tr>
<tr class="separator:ab56fe7eeee5ef85db508031ff16ae385"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9f55eb420d98a19a5d785eb69c0ab488"><td class="memItemLeft" align="right" valign="top"><a id="a9f55eb420d98a19a5d785eb69c0ab488"></a>
byte&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmpr121.html#a9f55eb420d98a19a5d785eb69c0ab488">MHDrisingProx</a></td></tr>
<tr class="memdesc:a9f55eb420d98a19a5d785eb69c0ab488"><td class="mdescLeft">&#160;</td><td class="mdescRight">"Max Half Delta" rising value for proximity detection (AN3891/AN3893) &ndash; max: 63 <br /></td></tr>
<tr class="separator:a9f55eb420d98a19a5d785eb69c0ab488"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac662872c2470ac44a7e54c359ec6a018"><td class="memItemLeft" align="right" valign="top"><a id="ac662872c2470ac44a7e54c359ec6a018"></a>
byte&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmpr121.html#ac662872c2470ac44a7e54c359ec6a018">MHDfallingProx</a></td></tr>
<tr class="memdesc:ac662872c2470ac44a7e54c359ec6a018"><td class="mdescLeft">&#160;</td><td class="mdescRight">"Max Half Delta" falling value for proximity detection (AN3891/AN3893) &ndash; max: 63 <br /></td></tr>
<tr class="separator:ac662872c2470ac44a7e54c359ec6a018"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0d12d72edf0b1bc55c20010d7d24e63f"><td class="memItemLeft" align="right" valign="top"><a id="a0d12d72edf0b1bc55c20010d7d24e63f"></a>
byte&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmpr121.html#a0d12d72edf0b1bc55c20010d7d24e63f">NHDrisingProx</a></td></tr>
<tr class="memdesc:a0d12d72edf0b1bc55c20010d7d24e63f"><td class="mdescLeft">&#160;</td><td class="mdescRight">"Noise Half Delta" rising value for proximity detection (AN3891/AN3893) &ndash; max: 63 <br /></td></tr>
<tr class="separator:a0d12d72edf0b1bc55c20010d7d24e63f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aaa10aa6e7421209d48763a2101b7e414"><td class="memItemLeft" align="right" valign="top"><a id="aaa10aa6e7421209d48763a2101b7e414"></a>
byte&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmpr121.html#aaa10aa6e7421209d48763a2101b7e414">NHDfallingProx</a></td></tr>
<tr class="memdesc:aaa10aa6e7421209d48763a2101b7e414"><td class="mdescLeft">&#160;</td><td class="mdescRight">"Noise Half Delta" falling value for proximity detection (AN3891/AN3893) &ndash; max: 63 <br /></td></tr>
<tr class="separator:aaa10aa6e7421209d48763a2101b7e414"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a05d29e8f4b36d9a7847e0fa3e829b216"><td class="memItemLeft" align="right" valign="top"><a id="a05d29e8f4b36d9a7847e0fa3e829b216"></a>
byte&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmpr121.html#a05d29e8f4b36d9a7847e0fa3e829b216">NHDtouchedProx</a></td></tr>
<tr class="memdesc:a05d29e8f4b36d9a7847e0fa3e829b216"><td class="mdescLeft">&#160;</td><td class="mdescRight">"Noise Half Delta" touched value for proximity detection (AN3891/AN3893) &ndash; max: 63 <br /></td></tr>
<tr class="separator:a05d29e8f4b36d9a7847e0fa3e829b216"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a290924ddcfb2e2ef0fd5ac6b91919c9f"><td class="memItemLeft" align="right" valign="top"><a id="a290924ddcfb2e2ef0fd5ac6b91919c9f"></a>
byte&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmpr121.html#a290924ddcfb2e2ef0fd5ac6b91919c9f">NCLrisingProx</a></td></tr>
<tr class="memdesc:a290924ddcfb2e2ef0fd5ac6b91919c9f"><td class="mdescLeft">&#160;</td><td class="mdescRight">"Noise Count Limit" rising value for proximity detection (AN3891/AN3893) <br /></td></tr>
<tr class="separator:a290924ddcfb2e2ef0fd5ac6b91919c9f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a39edec46c4e863afdd39e4665ecfb7ab"><td class="memItemLeft" align="right" valign="top"><a id="a39edec46c4e863afdd39e4665ecfb7ab"></a>
byte&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmpr121.html#a39edec46c4e863afdd39e4665ecfb7ab">NCLfallingProx</a></td></tr>
<tr class="memdesc:a39edec46c4e863afdd39e4665ecfb7ab"><td class="mdescLeft">&#160;</td><td class="mdescRight">"Noise Count Limit" falling value for proximity detection (AN3891/AN3893) <br /></td></tr>
<tr class="separator:a39edec46c4e863afdd39e4665ecfb7ab"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a648bc0ab11de9c67a74553e522f0fb3c"><td class="memItemLeft" align="right" valign="top"><a id="a648bc0ab11de9c67a74553e522f0fb3c"></a>
byte&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmpr121.html#a648bc0ab11de9c67a74553e522f0fb3c">NCLtouchedProx</a></td></tr>
<tr class="memdesc:a648bc0ab11de9c67a74553e522f0fb3c"><td class="mdescLeft">&#160;</td><td class="mdescRight">"Noise Count Limit" touched value for proximity detection (AN3891/AN3893) <br /></td></tr>
<tr class="separator:a648bc0ab11de9c67a74553e522f0fb3c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a07b1e5476592647c749b0983cd144a0f"><td class="memItemLeft" align="right" valign="top"><a id="a07b1e5476592647c749b0983cd144a0f"></a>
byte&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmpr121.html#a07b1e5476592647c749b0983cd144a0f">FDLrisingProx</a></td></tr>
<tr class="memdesc:a07b1e5476592647c749b0983cd144a0f"><td class="mdescLeft">&#160;</td><td class="mdescRight">"Filter Delay Limit" rising value for proximity detection (AN3891/AN3893) <br /></td></tr>
<tr class="separator:a07b1e5476592647c749b0983cd144a0f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a87eff5794f34d0950951d03e3aedbfea"><td class="memItemLeft" align="right" valign="top"><a id="a87eff5794f34d0950951d03e3aedbfea"></a>
byte&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmpr121.html#a87eff5794f34d0950951d03e3aedbfea">FDLfallingProx</a></td></tr>
<tr class="memdesc:a87eff5794f34d0950951d03e3aedbfea"><td class="mdescLeft">&#160;</td><td class="mdescRight">"Filter Delay Limit" falling value for proximity detection (AN3891/AN3893) <br /></td></tr>
<tr class="separator:a87eff5794f34d0950951d03e3aedbfea"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af280f0d65be0d1ef87c95bbd23431dd8"><td class="memItemLeft" align="right" valign="top"><a id="af280f0d65be0d1ef87c95bbd23431dd8"></a>
byte&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmpr121.html#af280f0d65be0d1ef87c95bbd23431dd8">FDLtouchedProx</a></td></tr>
<tr class="memdesc:af280f0d65be0d1ef87c95bbd23431dd8"><td class="mdescLeft">&#160;</td><td class="mdescRight">"Filter Delay Limit" touched value for proximity detection (AN3891/AN3893) <br /></td></tr>
<tr class="separator:af280f0d65be0d1ef87c95bbd23431dd8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab8b2355f80f071d7ee995919745f9676"><td class="memItemLeft" align="right" valign="top"><a id="ab8b2355f80f071d7ee995919745f9676"></a>
byte&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmpr121.html#ab8b2355f80f071d7ee995919745f9676">debounceTouch</a></td></tr>
<tr class="memdesc:ab8b2355f80f071d7ee995919745f9676"><td class="mdescLeft">&#160;</td><td class="mdescRight">Set "Debounce" count for touches (times a detection must be sampled) &ndash; max: 7. <br /></td></tr>
<tr class="separator:ab8b2355f80f071d7ee995919745f9676"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a22a0845652b71cda0e83ed6d79f65f6e"><td class="memItemLeft" align="right" valign="top"><a id="a22a0845652b71cda0e83ed6d79f65f6e"></a>
byte&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmpr121.html#a22a0845652b71cda0e83ed6d79f65f6e">debounceRelease</a></td></tr>
<tr class="memdesc:a22a0845652b71cda0e83ed6d79f65f6e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Set "Debounce" count for releases (times a detection must be sampled) &ndash; max: 7. <br /></td></tr>
<tr class="separator:a22a0845652b71cda0e83ed6d79f65f6e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:acf03a40d571975a5c9b75c2a2986c0e5"><td class="memItemLeft" align="right" valign="top"><a id="acf03a40d571975a5c9b75c2a2986c0e5"></a>
<a class="el" href="_quick_mpr121_enums_8h.html#aaa86b74f0f6bbeaf579ef62e5ba75a59">mpr121FilterFFI</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmpr121.html#acf03a40d571975a5c9b75c2a2986c0e5">FFI</a></td></tr>
<tr class="memdesc:acf03a40d571975a5c9b75c2a2986c0e5"><td class="mdescLeft">&#160;</td><td class="mdescRight">"First Filter Iterations" (number of samples taken for the first level of filtering) <br /></td></tr>
<tr class="separator:acf03a40d571975a5c9b75c2a2986c0e5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5eda5d5235df63b7fa038d78da92ec50"><td class="memItemLeft" align="right" valign="top"><a id="a5eda5d5235df63b7fa038d78da92ec50"></a>
byte&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmpr121.html#a5eda5d5235df63b7fa038d78da92ec50">globalCDC</a></td></tr>
<tr class="memdesc:a5eda5d5235df63b7fa038d78da92ec50"><td class="mdescLeft">&#160;</td><td class="mdescRight">Global "Charge Discharge Current" (μA), not used if autoconfig is enabled &ndash; max 63. <br /></td></tr>
<tr class="separator:a5eda5d5235df63b7fa038d78da92ec50"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a506bf0b970d61987b28e60ba5a7d15c8"><td class="memItemLeft" align="right" valign="top"><a id="a506bf0b970d61987b28e60ba5a7d15c8"></a>
<a class="el" href="_quick_mpr121_enums_8h.html#ad2a688c361d603bdaf0b8879dd085f88">mpr121FilterCDT</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmpr121.html#a506bf0b970d61987b28e60ba5a7d15c8">globalCDT</a></td></tr>
<tr class="memdesc:a506bf0b970d61987b28e60ba5a7d15c8"><td class="mdescLeft">&#160;</td><td class="mdescRight">Global "Charge Discharge Time" (μs), not used if autoconfig is enabled. <br /></td></tr>
<tr class="separator:a506bf0b970d61987b28e60ba5a7d15c8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abd189b5bd17af7bd2d9a52d2886245c7"><td class="memItemLeft" align="right" valign="top"><a id="abd189b5bd17af7bd2d9a52d2886245c7"></a>
<a class="el" href="_quick_mpr121_enums_8h.html#a12b1b80082b53ac225e90c55d84b276c">mpr121FilterSFI</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmpr121.html#abd189b5bd17af7bd2d9a52d2886245c7">SFI</a></td></tr>
<tr class="memdesc:abd189b5bd17af7bd2d9a52d2886245c7"><td class="mdescLeft">&#160;</td><td class="mdescRight">"Second Filter Iterations" (number of samples taken for the second level of filtering) <br /></td></tr>
<tr class="separator:abd189b5bd17af7bd2d9a52d2886245c7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a69e20a3174c331f0aeee7885cfa1ea0c"><td class="memItemLeft" align="right" valign="top"><a id="a69e20a3174c331f0aeee7885cfa1ea0c"></a>
<a class="el" href="_quick_mpr121_enums_8h.html#a8e414d6fc4ce0749a157b630f1eb9235">mpr121FilterESI</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmpr121.html#a69e20a3174c331f0aeee7885cfa1ea0c">ESI</a></td></tr>
<tr class="memdesc:a69e20a3174c331f0aeee7885cfa1ea0c"><td class="mdescLeft">&#160;</td><td class="mdescRight">"Electrode Sample Interval" (ms) <br /></td></tr>
<tr class="separator:a69e20a3174c331f0aeee7885cfa1ea0c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:acb0ec0b0b8c94757403e6393530db490"><td class="memItemLeft" align="right" valign="top"><a id="acb0ec0b0b8c94757403e6393530db490"></a>
<a class="el" href="_quick_mpr121_enums_8h.html#ad94d7cdee3b977218d2f0c848f2ff9cc">mpr121ElectrodeConfigCL</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmpr121.html#acb0ec0b0b8c94757403e6393530db490">calLock</a></td></tr>
<tr class="memdesc:acb0ec0b0b8c94757403e6393530db490"><td class="mdescLeft">&#160;</td><td class="mdescRight">"Calibration Lock" (baseline tracking and initial value settings) <br /></td></tr>
<tr class="separator:acb0ec0b0b8c94757403e6393530db490"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a300a0ac072161e7b92b4411d90fbcda3"><td class="memItemLeft" align="right" valign="top"><a id="a300a0ac072161e7b92b4411d90fbcda3"></a>
<a class="el" href="_quick_mpr121_enums_8h.html#aa268c1a186051b99ccff743d53ec079d">mpr121ElectrodeConfigProx</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmpr121.html#a300a0ac072161e7b92b4411d90fbcda3">proxEnable</a></td></tr>
<tr class="memdesc:a300a0ac072161e7b92b4411d90fbcda3"><td class="mdescLeft">&#160;</td><td class="mdescRight">ELEPROX_EN: sets what electrodes will be used for proximity detection. <br /></td></tr>
<tr class="separator:a300a0ac072161e7b92b4411d90fbcda3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7b46c1ae611e4ce9e8baabe4171dd02c"><td class="memItemLeft" align="right" valign="top"><a id="a7b46c1ae611e4ce9e8baabe4171dd02c"></a>
byte&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmpr121.html#a7b46c1ae611e4ce9e8baabe4171dd02c">autoConfigUSL</a></td></tr>
<tr class="memdesc:a7b46c1ae611e4ce9e8baabe4171dd02c"><td class="mdescLeft">&#160;</td><td class="mdescRight">"Up-Side Limit" for auto calibration &ndash; if not set when starting, this will be automatically set to the ideal value for 1.8V supply <br /></td></tr>
<tr class="separator:a7b46c1ae611e4ce9e8baabe4171dd02c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a496355951e0e74a10ad17c9ca26bf696"><td class="memItemLeft" align="right" valign="top"><a id="a496355951e0e74a10ad17c9ca26bf696"></a>
byte&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmpr121.html#a496355951e0e74a10ad17c9ca26bf696">autoConfigLSL</a></td></tr>
<tr class="memdesc:a496355951e0e74a10ad17c9ca26bf696"><td class="mdescLeft">&#160;</td><td class="mdescRight">"Low-Side Limit" for auto calibration &ndash; if not set when starting, this will be automatically set based on USL <br /></td></tr>
<tr class="separator:a496355951e0e74a10ad17c9ca26bf696"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af14fe4e91ff889f315b2cab0e231ab8b"><td class="memItemLeft" align="right" valign="top"><a id="af14fe4e91ff889f315b2cab0e231ab8b"></a>
byte&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmpr121.html#af14fe4e91ff889f315b2cab0e231ab8b">autoConfigTL</a></td></tr>
<tr class="memdesc:af14fe4e91ff889f315b2cab0e231ab8b"><td class="mdescLeft">&#160;</td><td class="mdescRight">"Target Level" for auto calibration &ndash; if not set when starting, this will be automatically set based on USL <br /></td></tr>
<tr class="separator:af14fe4e91ff889f315b2cab0e231ab8b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ada8fd903e360417faa7c3fb000828138"><td class="memItemLeft" align="right" valign="top"><a id="ada8fd903e360417faa7c3fb000828138"></a>
<a class="el" href="_quick_mpr121_enums_8h.html#a4da370687b4d1e260673bf75f4cd478c">mpr121AutoConfigRetry</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmpr121.html#ada8fd903e360417faa7c3fb000828138">autoConfigRetry</a></td></tr>
<tr class="memdesc:ada8fd903e360417faa7c3fb000828138"><td class="mdescLeft">&#160;</td><td class="mdescRight">Number of retries for failed auto-config before out of range will be set. <br /></td></tr>
<tr class="separator:ada8fd903e360417faa7c3fb000828138"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac178379eebb5d04a1fb4c9cac669c2d6"><td class="memItemLeft" align="right" valign="top"><a id="ac178379eebb5d04a1fb4c9cac669c2d6"></a>
<a class="el" href="_quick_mpr121_enums_8h.html#a7eb55b1477d67983d92f54424d7e1484">mpr121AutoConfigBVA</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmpr121.html#ac178379eebb5d04a1fb4c9cac669c2d6">autoConfigBaselineAdjust</a></td></tr>
<tr class="memdesc:ac178379eebb5d04a1fb4c9cac669c2d6"><td class="mdescLeft">&#160;</td><td class="mdescRight">"Baseline Value Adjust" changes how the baseline registers will be set after auto-configuration completes <br /></td></tr>
<tr class="separator:ac178379eebb5d04a1fb4c9cac669c2d6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a00a928e06f9f069ca3ff6b1625043bb3"><td class="memItemLeft" align="right" valign="top"><a id="a00a928e06f9f069ca3ff6b1625043bb3"></a>
bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmpr121.html#a00a928e06f9f069ca3ff6b1625043bb3">autoConfigEnableReconfig</a></td></tr>
<tr class="memdesc:a00a928e06f9f069ca3ff6b1625043bb3"><td class="mdescLeft">&#160;</td><td class="mdescRight">"Automatic Reconfiguration Enable" will try to reconfigure out of range (failed) channels every sampling interval <br /></td></tr>
<tr class="separator:a00a928e06f9f069ca3ff6b1625043bb3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a094c99cc36c9b8150c50001b722018a6"><td class="memItemLeft" align="right" valign="top"><a id="a094c99cc36c9b8150c50001b722018a6"></a>
bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmpr121.html#a094c99cc36c9b8150c50001b722018a6">autoConfigEnableCalibration</a></td></tr>
<tr class="memdesc:a094c99cc36c9b8150c50001b722018a6"><td class="mdescLeft">&#160;</td><td class="mdescRight">"Automatic Configuration Enable" will enable/disable auto-configuration when entering run mode <br /></td></tr>
<tr class="separator:a094c99cc36c9b8150c50001b722018a6"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<a name="details" id="details"></a><h2 class="groupheader">Detailed Description</h2>
<div class="textblock"><p>Main <a class="el" href="classmpr121.html" title="Main mpr121 class.">mpr121</a> class. </p>
<p>Use one instance per MPR121. </p>
</div><h2 class="groupheader">Constructor &amp; Destructor Documentation</h2>
<a id="ac6a476c441a682a5573e7b8957f375ab"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac6a476c441a682a5573e7b8957f375ab">&#9670;&nbsp;</a></span>mpr121()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">mpr121::mpr121 </td>
          <td>(</td>
          <td class="paramtype">byte&#160;</td>
          <td class="paramname"><em>addr</em> = <code>0</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">TwoWire *&#160;</td>
          <td class="paramname"><em>wire</em> = <code>&amp;Wire</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Creates an MPR121 device with sane default settings. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">addr</td><td>The I2C address to use. If not specified (or ==0), the next valid address will be chosen automatically. </td></tr>
    <tr><td class="paramname">wire</td><td>You can pass in an alternative TwoWire instance. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<h2 class="groupheader">Member Function Documentation</h2>
<a id="acf4591d8841ef5ab9c0f9394877d6b72"></a>
<h2 class="memtitle"><span class="permalink"><a href="#acf4591d8841ef5ab9c0f9394877d6b72">&#9670;&nbsp;</a></span>begin()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void mpr121::begin </td>
          <td>(</td>
          <td class="paramtype">unsigned long&#160;</td>
          <td class="paramname"><em>clock</em> = <code>400000</code></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Optional alternative to using Wire.begin() and Wire.setClock(). </p>
<p>Also has a built-in delay to ensure MPR121s are ready. </p>

</div>
</div>
<a id="a38b74ad084a9971e4682572e5c1560ee"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a38b74ad084a9971e4682572e5c1560ee">&#9670;&nbsp;</a></span>clearOverCurrent()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void mpr121::clearOverCurrent </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Clears the over current flag. </p>
<p>(over current on REXT pin, probably shouldn't happen in normal operation) </p>

</div>
</div>
<a id="aafa21063d20fbb7fb4fa89b081231c94"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aafa21063d20fbb7fb4fa89b081231c94">&#9670;&nbsp;</a></span>readOORState()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">short mpr121::readOORState </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Reads the 15 out of range bits. </p>
<p>[13]: auto-config fail flag [14]: auto-reconfig fail flag </p>

</div>
</div>
<a id="a16e21396fbe46fa375737f3cfe9ad860"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a16e21396fbe46fa375737f3cfe9ad860">&#9670;&nbsp;</a></span>readOverCurrent()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool mpr121::readOverCurrent </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Reads the over current flag. </p>
<p>(over current on REXT pin, probably shouldn't happen in normal operation) </p>

</div>
</div>
<a id="a63ae10501fb6b3e51c3d8ee19907fbd5"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a63ae10501fb6b3e51c3d8ee19907fbd5">&#9670;&nbsp;</a></span>readTouchState() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">short mpr121::readTouchState </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Reads the 13 touch state bits. </p>
<p>Also use this for reading GPIO inputs. </p>

</div>
</div>
<a id="ac3e687df193f083c5b215c28122cffd7"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac3e687df193f083c5b215c28122cffd7">&#9670;&nbsp;</a></span>readTouchState() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool mpr121::readTouchState </td>
          <td>(</td>
          <td class="paramtype">byte&#160;</td>
          <td class="paramname"><em>electrode</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Reads one touch state bool. </p>
<p>Also use this for reading GPIO inputs.</p>
<p>When multiple touches must be read, using the variant that returns data for all 13 is preferred. This does implement a simple cache though, so performance shouldn't be drastically different. </p>

</div>
</div>
<a id="a8d889cab82974749203f22c5b17b97a4"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a8d889cab82974749203f22c5b17b97a4">&#9670;&nbsp;</a></span>setAllThresholds()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void mpr121::setAllThresholds </td>
          <td>(</td>
          <td class="paramtype">byte&#160;</td>
          <td class="paramname"><em>touched</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">byte&#160;</td>
          <td class="paramname"><em>released</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>prox</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>A quick way to set all ::touchThresholds and ::releaseThresholds. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">prox</td><td>Whether to set proximity detection thresholds too. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a390d14e572542715030b38228ba1b148"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a390d14e572542715030b38228ba1b148">&#9670;&nbsp;</a></span>setGPIOMode() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void mpr121::setGPIOMode </td>
          <td>(</td>
          <td class="paramtype">byte&#160;</td>
          <td class="paramname"><em>pin</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">byte&#160;</td>
          <td class="paramname"><em>count</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="_quick_mpr121_enums_8h.html#a3bbfc0ca52598381c8dcc6d45b08b4ea">mpr121GPIOMode</a>&#160;</td>
          <td class="paramname"><em>mode</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Sets pin mode for consecutive GPIO pins. </p>
<p>GPIO can be used on pins 4-11 when they aren't used for sensing. Use mode MPR_GPIO_MODE_OUTPUT_OPENDRAIN_HIGH for direct LED driving &ndash; it can source up to 12mA. </p>

</div>
</div>
<a id="a79321eedcc84a0d62445c8d120d2d98d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a79321eedcc84a0d62445c8d120d2d98d">&#9670;&nbsp;</a></span>setGPIOMode() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void mpr121::setGPIOMode </td>
          <td>(</td>
          <td class="paramtype">byte&#160;</td>
          <td class="paramname"><em>pin</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="_quick_mpr121_enums_8h.html#a3bbfc0ca52598381c8dcc6d45b08b4ea">mpr121GPIOMode</a>&#160;</td>
          <td class="paramname"><em>mode</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Sets pin mode for a single GPIO pin. </p>
<p>GPIO can be used on pins 4-11 when they aren't used for sensing. Use mode MPR_GPIO_MODE_OUTPUT_OPENDRAIN_HIGH for direct LED driving &ndash; it can source up to 12mA. </p>

</div>
</div>
<a id="a333400f6bc6ad369be09850c982c4785"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a333400f6bc6ad369be09850c982c4785">&#9670;&nbsp;</a></span>start()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void mpr121::start </td>
          <td>(</td>
          <td class="paramtype">byte&#160;</td>
          <td class="paramname"><em>electrodes</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Applies settings and enters run mode with a given number of electrodes. </p>
<p>Very much based on the quick start guide (AN3944). </p>

</div>
</div>
<a id="a82e0215c013429d7b2d88359fdacd162"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a82e0215c013429d7b2d88359fdacd162">&#9670;&nbsp;</a></span>writeGPIOAnalog() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void mpr121::writeGPIOAnalog </td>
          <td>(</td>
          <td class="paramtype">byte&#160;</td>
          <td class="paramname"><em>pin</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">byte&#160;</td>
          <td class="paramname"><em>count</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">byte&#160;</td>
          <td class="paramname"><em>value</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Writes an "analog" (PWM) value to consecutive GPIO pins. </p>
<p>Max value is 15</p>
<p>Pin 9 apparently has a logic bug and pin 10 must also have its data set high for it to work. (see <a href="https://community.nxp.com/thread/305474">https://community.nxp.com/thread/305474</a>) </p>

</div>
</div>
<a id="a671d4894de14e9b197a54b5ee264d85f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a671d4894de14e9b197a54b5ee264d85f">&#9670;&nbsp;</a></span>writeGPIOAnalog() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void mpr121::writeGPIOAnalog </td>
          <td>(</td>
          <td class="paramtype">byte&#160;</td>
          <td class="paramname"><em>pin</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">byte&#160;</td>
          <td class="paramname"><em>value</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Writes an "analog" (PWM) value to a single GPIO pin. </p>
<p>Max value is 15</p>
<p>Pin 9 apparently has a logic bug and pin 10 must also have its data set high for it to work. (see <a href="https://community.nxp.com/thread/305474">https://community.nxp.com/thread/305474</a>) </p>

</div>
</div>
<hr/>The documentation for this class was generated from the following files:<ul>
<li>src/<a class="el" href="_quick_mpr121_8h_source.html">QuickMpr121.h</a></li>
<li>src/QuickMpr121.cpp</li>
</ul>
</div><!-- contents -->
</div><!-- doc-content -->
<!-- start footer part -->
<div id="nav-path" class="navpath"><!-- id is needed for treeview function! -->
  <ul>
    <li class="navelem"><a class="el" href="classmpr121.html">mpr121</a></li>
    <li class="footer">Generated by
    <a href="http://www.doxygen.org/index.html">
    <img class="footer" src="doxygen.png" alt="doxygen"/></a> 1.8.17 </li>
  </ul>
</div>
</body>
</html>
